<%= template.import("header.html", {}, "header") %>
<div class="page">
    <%= template.import("lateralbar.html", {}, "lateralbar") %>
    <div class="content">
        <section id="intro" class="intro">
            <article>
                <p>HappyRhino gives structure to client-side web applications by bringing a complete build system (using Grunt)
                    with a a rich API similar to Backbone.js.</p>
                <p>hr.js is an open-source component of <a href="https://friendco.de">FriendCode</a>.</p>
                <p>Current version is <b><%- hr.configs.version %></b>, code is disponible on GitHub : <a href="https://github.com/FriendCode/hr.js">FriendCode/hr.js</a>.</p>
                <p>
                    Checkout a list of web-applications which are using hr.js :
                    <ul>
                        <li><a href="https://www.codebox.io"><b>Codebox</b></a>, Open Cloud IDE.</li>
                        <li><a href="http://doks.io"><b>Doks.io</b></a>, Searching documentation made easy.</li>
                        <li><a href="https://github.com/SamyPesse/tv.js"><b>TV.js</b></a>, Apple TV for Torrent Streaming in JS (Node/Chrome).</li>
                        <li><a href="http://www.reportr.io"><b>Reportr</b></a>, Your life's personal dashboard.</li>
                        <li><a href="https://github.com/FriendCode/gitrap"><b>GitRap</b></a>, Distributed Git based Forums.</li>
                    </ul>
                </p>
                <p>
                    <%= view.component("counter", {
                        prefix: "Documentation updated ",
                        suffix: " ago.",
                        from: new Date(hr.configs.revision)
                    }) %>
                </p>
                <p>
                    <iframe src="http://ghbtns.com/github-btn.html?user=FriendCode&repo=hr.js&type=watch&count=true"allowtransparency="true" frameborder="0" scrolling="0" width="85" height="20"></iframe>
                    <iframe src="http://ghbtns.com/github-btn.html?user=FriendCode&repo=hr.js&type=fork&count=true"allowtransparency="true" frameborder="0" scrolling="0" width="105" height="20"></iframe>
                </p>
            </article>
        </section>

        <section id="install">
            <h2><a href="<%- hr.urls.route("install") %>">Installation</a></h2>
            <article>
                <p>Simply install hr.js using <b>NPM</b> :</p>
                <p><code>npm install hr.js</code></p>
            </article>   
        </section>

        <section id="getstarted">
            <h2><a href="<%- hr.urls.route("getstarted") %>">Get started</a></h2>
            <article>
                
            </article>   
        </section>

        <section id="build">
            <h2><a href="<%- hr.urls.route("build") %>">Build system</a></h2>
            <article id="build/structure">
                <h3><a href="<%- hr.urls.route("build/structure") %>">Real structure for client-side application</a></h3>
                <p>hr.js as been build to bring a real structure to client-side application code.</p>
                <%= view.component("code", {code: "build/structure.txt"}) %>
            </article>
            <article id="build/application">
                <h3><a href="<%- hr.urls.route("build/application") %>">Defining an application</a></h3>
                <p>HappyRhino is using Grunt, An application in hr.js need a base build configuration, this configuration is stored in a "Gruntile.js" file:</p>
                <%= view.component("code", {code: "build/Gruntfile.js"}) %>
                <p>Here is a list of all the differents options for build process :</p>
                <%= view.component("code", {code: "build/options.js"}) %>
            </article>
            <article id="build/run">
                <h3><a href="<%- hr.urls.route("build/run") %>">Build &amp; Run your application</a></h3>
                <p>Coming soon.</p>
            </article>
            <article id="build/module">
                <h3><a href="<%- hr.urls.route("build/module") %>">Modularity</a></h3>
                <p>HappyRhino uses <a href="http://requirejs.org/">require.js</a> as module loader.</p>
                <%= view.component("code", {code: "build/module.js"}) %>
            </article> 
            <article id="build/args">
                <h3><a href="<%- hr.urls.route("build/args") %>">Arguments and revisions</a></h3>
                <p>Each build use a unique revision timestamp, this revision id is useful for avoiding cache during resources requests.</p>
                <%= view.component("code", {code: "build/revision.js", run: true}) %>
                <p>The build process can pass arguments to the client side application :</p>
                <%= view.component("code", {code: "build/options_args.js"}) %>
                <p>And arguments are simply accessible in the client side :</p>
                <%= view.component("code", {code: "build/args.js"}) %>
            </article>   
        </section>

        <section id="application">
            <h2><a href="<%- hr.urls.route("application") %>">Application</a></h2>
            <p>The module <b>Application</b> represent the base for your application, it uses to describe the main entry point of your application and its configurations.</p>
            <p>The class <b>Application</b> inherit from <a href="<%- hr.urls.route("views") %>"><code>hr.View</code></a>.</p>

            <article id="application/extend">
                <h3><a href="<%- hr.urls.route("application/extend") %>">extend</a> <code>hr.Application.extend(properties, [classProperties])</code></h3>
                <p>To create an <b>Application</b> class of your own, <a href="<%- hr.urls.route("class/extend") %>">extend</a> <code>hr.Application</code>, providing instance properties, as well as optional <b>classProperties</b> to be attached directly to the application's constructor function.</p>
                <%= view.component("code", {code: "application/extend.js"}) %>
            </article>

            <article id="application/run">
                <h3><a href="<%- hr.urls.route("application/run") %>">run</a> <code>application.run()</code></h3>
                <p>After extending the <code>hr.Application</code> class, you need to start your new application.</p>
                <%= view.component("code", {code: "application/run.js"}) %>
            </article>

            <article id="application/title">
                <h3><a href="<%- hr.urls.route("application/title") %>">title</a> <code>application.title([newValue, absolute])</code></h3>
                <p>Get or set the page title, <b>title</b> could be relative to the application (format: <code>@appname - @title</code>) or absolute (format: <code>@title</code>). This method use <a href="<%- hr.urls.route("application/head") %>">head</a>.</p>
                <%= view.component("code", {code: "application/title.js"}) %>
            </article>

            <article id="application/head">
                <h3><a href="<%- hr.urls.route("application/head") %>">head</a> <code>application.head</code></h3>
                <p>Property <code>head</code> of application let you easily manage page informations such as <b>title</b>, <b>metas</b>, <b>links</b>, <b>crawling</b>.</p>
                <%= view.component("code", {code: "application/head.js"}) %>
            </article>
        </section>

        <section id="view">
            <h2><a href="<%- hr.urls.route("view") %>">View</a></h2>
            <article id="view/extend">
                <h3><a href="<%- hr.urls.route("view/extend") %>">extend</a> <code>hr.View.extend(properties, [classProperties])</code></h3>
                <p>The first thing who have to do for creating a new view is extending the basic view class.</p>
                <%= view.component("code", {code: "view/extend.js"}) %>
            </article>
            <article id="view/template">
                <h3><a href="<%- hr.urls.route("view/template") %>">template</a></h3>
                <p>Views in hr.js can easily uses templates by defining property <code>template</code> with the template name and uses <code>templateContext</code> to return the variables for the template.</p>
                <p>For using templates, you need to specify the ressource loader for templates :  <a href="<%- hr.urls.route("template/load") %>"><code>Templating/Loading</code></a>.</p>
                <%= view.component("code", {code: "view/template.js"}) %>
                <p><code>template</code> name could alse be given by a function, for example :</p>
                <%= view.component("code", {code: "view/template_function.js"}) %>
            </article>
            <article id="view/render">
                <h3><a href="<%- hr.urls.route("view/render") %>">render</a> <code>view.render()</code></h3>
                <p>Render the view is easy using the method render, you can bind the events <code>"render"</code> (after rendering) or <code>"ready"</code> (first time rendering).</p>
                <%= view.component("code", {code: "view/render.js"}) %>
                <p>By default, view use <code>template</code> for rendering, but you can redefine <code>render</code> :</p>
                <%= view.component("code", {code: "view/render_extend.js"}) %>
            </article>
            <article id="view/events">
                <h3><a href="<%- hr.urls.route("view/events") %>">events</a></h3>
                <p>Events are written in the format <code>{"event selector": "callback"}</code>. The callback may be either the name of a method on the view, or a direct function body. Omitting the selector causes the event to be bound to the view's root element (<code>this.el</code>). By default, delegateEvents is called within the View's constructor for you, so if you have a simple events hash, all of your DOM events will always already be connected, and you will never have to call this function yourself.</p>

                <p>The events property may also be defined as a function that returns an events hash, to make it easier to programmatically define your events, as well as inherit them from parent views.</p>

                <p>Using delegated events provides a number of advantages over manually using jQuery to bind events to child elements during render. All attached callbacks are bound to the view before being handed off to jQuery, so when the callbacks are invoked, this continues to refer to the view object. When <code>delegateEvents</code> is run, perhaps with a different events hash, all callbacks are removed and delegated afresh — useful for views which need to behave differently when in different modes.</p>
                <%= view.component("code", {code: "view/events.js"}) %>
            </article>
            <article id="view/components">
                <h3><a href="<%- hr.urls.route("view/components") %>">components</a></h3>
                <p>Views in hr can easily manage sub-views using components, these components can be added directly in the templates : <a href="<%- hr.urls.route("template/components") %>">Learn more about it</a></p>
                <p>Defining a view as a component for temlate is really easy :</p>
                <%= view.component("code", {code: "view/component.js"}) %>
            </article>
        </section>

        <section id="template">
            <h2><a href="<%- hr.urls.route("template") %>">Templating</a></h2>
            <article id="template/syntax">
                <h3><a href="<%- hr.urls.route("template/syntax") %>">Syntax</a></h3>
                <p>hr.js allow view to manage in a simple way templates.</p>
                <p>Template can interpolate variables, using <code>&lt;%= … %&gt;</code>, as well as execute arbitrary JavaScript code, with <code>&lt;% … %&gt;</code>. If you wish to interpolate a value, and have it be HTML-escaped, use <code>&lt;%- … %&gt;</code>.</p>
                <%= view.component("code", {code: "template/syntax.html"}) %>
            </article>
            <article id="template/components">
                <h3><a href="<%- hr.urls.route("template/components") %>">Components</a></h3>
                <p>Components in <b>template</b> is a great way to manage child views.</p>
                <p>Template components have to been registrated using <a href="<%- hr.urls.route("view/registerComponent") %>"><code>hr.View.Template.registerComponent</code></a></p>
                <%= view.component("code", {code: "template/components.html"}) %>
                <p>You can after that easily access to components views in your view :</p>
                <%= view.component("code", {code: "template/components.js"}) %>
            </article>
            <article id="template/load">
                <h3><a href="<%- hr.urls.route("template/load") %>">Loading</a></h3>
                <p>For using templates, you need to specify to hr how to load a template by name. Templates use the resources namespace "templates" :</p>
                <%= view.component("code", {code: "template/load.js"}) %>
            </article>
        </section>

        <section id="class">
            <h2><a href="<%- hr.urls.route("class") %>">Class</a></h2>
            <p>The module <b>class</b> is the base for all the modules in hr.js, giving the object the ability to bind and trigger custom named events. 
            Events do not have to be declared before they are bound, and may take passed arguments.</p>
            <article id="class/extend">
                <h3><a href="<%- hr.urls.route("class/extend") %>">extend</a> <code>hr.Class.extend(properties, [classProperties])</code></h3>
                <p>To create a <b>class</b> of your own, you extend <code>hr.Class</code> and provide instance <b>properties</b>, as well as optional <b>classProperties</b> to be attached directly to the constructor function.</^>

                <p><b>extend</b> correctly sets up the prototype chain, so subclasses created with <b>extend</b> can be further extended and subclassed as far as you like.</p>
                <%= view.component("code", {code: "class/extend.js"}) %>
            </article>
            <article id="class/initialize">
                <h3><a href="<%- hr.urls.route("class/initialize") %>">initialize</a> <code>new hr.Class([options])</code></h3>
                <p><b>initialize</b> represents the constructor of the class, object passed to <b>initialize</b> is merged with <a href="<%- hr.urls.route("class/defaults") %>"><code>defaults</code></a> into <code>options</code>.</p>
                <%= view.component("code", {code: "class/initialize.js", run: true}) %>
            </article>
            <article id="class/defaults">
                <h3><a href="<%- hr.urls.route("class/defaults") %>">defaults</a> <code>hr.Class.defaults</code></h3>
                <p><b>defaults</b> let you define the defaults properties of the objects. Properties of the objects are stored into <code>options</code>.</p>
                <%= view.component("code", {code: "class/defaults.js", run: true}) %>
            </article>
            <article id="class/on">
                <h3><a href="<%- hr.urls.route("class/on") %>">on</a> <code>object.on(event, callback, [context])</code></h3>
                <p>Bind a callback function to an object. The callback will be invoked whenever the <b>event</b> is fired. If you have a large number of different events on a page, the convention is to use colons to namespace them: <code>"poll:start"</code>, or <code>"change:selection"</code>. The event string may also be a space-delimited list of several events...</p>
                <%= view.component("code", {code: "class/on.js"}) %>
                <p>To supply a context value for this when the callback is invoked, pass the optional third argument: <code>object.on('change', this.render, this)</code></p>
                <p>Callbacks bound to the special <code>"all"</code> event will be triggered when any event occurs, and are passed the name of the event as the first argument. For example, to proxy all events from one object to another:</p>
                <%= view.component("code", {code: "class/on_all.js"}) %>
                <p>All event methods also support an event map syntax, as an alternative to positional arguments:</p>
                <%= view.component("code", {code: "class/on_map.js"}) %>
                <p>hr.js alse supports hierarchical events:</p>
                <%= view.component("code", {code: "class/on_sub.js", run: true}) %>
            </article>
            <article id="class/off">
                <h3><a href="<%- hr.urls.route("class/off") %>">off</a> <code>object.off([event], [callback], [context])</code></h3>
                <p>Remove a previously-bound <b>callback</b> function from an object. If no <b>context</b> is specified, all of the versions of the callback with different contexts will be removed. If no callback is specified, all callbacks for the <b>event</b> will be removed. If no event is specified, callbacks for all events will be removed.</p>
                <%= view.component("code", {code: "class/off.js"}) %>
            </article>
            <article id="class/trigger">
                <h3><a href="<%- hr.urls.route("class/trigger") %>">trigger</a> <code>object.trigger(event, [*args])</code></h3>
                <p>Trigger callbacks for the given <b>event</b>, or space-delimited list of events. Subsequent arguments to <b>trigger</b> will be passed along to the event callbacks.</p>
            </article>
            <article id="class/triggerOnly">
                <h3><a href="<%- hr.urls.route("class/triggerOnly") %>">triggerOnly</a> <code>object.triggerOnly(event, [*args])</code></h3>
                <p>Trigger callbacks for the given <b>event</b>, or space-delimited list of events. Subsequent arguments to <b>trigger</b> will be passed along to the event callbacks. But don't trigger parents events.</p>
            </article>
            <article id="class/once">
                <h3><a href="<%- hr.urls.route("class/once") %>">once</a> <code>object.once(event, callback, [context])</code></h3>
                <p>Just like <a href="<%- hr.urls.route("class/on") %>">on</a>, but causes the bound callback to only fire once before being removed. Handy for saying "the next time that X happens, do this".</p>
            </article>
        </section>

        <section id="model">
            <h2><a href="<%- hr.urls.route("model") %>">Model</a></h2>
            <p>The class <b>Model</b> let you define complex model in your applciation.</p>

            <article id="model/extend">
                <h3><a href="<%- hr.urls.route("model/extend") %>">extend</a> <code>hr.Model.extend(properties, [classProperties])</code></h3>
                <p>To create a <b>Model</b> class of your own, you extend <code>hr.Model</code> and provide instance <b>properties</b>, as well as optional <b>classProperties</b> to be attached directly to the constructor function.</p>
                <%= view.component("code", {code: "model/extend.js", run: true}) %>
            </article>

            <article id="model/initialize">
                <h3><a href="<%- hr.urls.route("model/initialize") %>">constructor / initialize</a> <code>new hr.Model([options], [attributes]) </code></h3>
                <p>When creating an instance of a model, you can pass in the initial values of the <b>attributes</b>, which will be <a href="<%- hr.urls.route("model/set") %>">set</a> on the model. If you define an initialize function, it will be invoked when the model is created.</p>
            </article>

            <article id="model/get">
                <h3><a href="<%- hr.urls.route("model/get") %>">get</a> <code>model.get(attribute, [default])</code></h3>
                <p>Get the current value of an attribute from the model. For example: <code>note.get("author.name")</code></p>
            </article>

            <article id="model/set">
                <h3><a href="<%- hr.urls.route("model/set") %>">set</a> <code>model.set(attributes, [options])</code></h3>
                <p>Set a hash of attributes (one or many) on the model. If any of the attributes change the model's state, a <code>"change"</code> event will be triggered on the model. Change events for specific attributes are also triggered, and you can bind to those as well, for example: <code>change:title</code>, and <code>change:content</code>. You may also pass individual keys and values.</p>
                <%= view.component("code", {code: "model/set.js", run: true}) %>
            </article>

            <article id="model/has">
                <h3><a href="<%- hr.urls.route("model/has") %>">has</a> <code>model.has(attribute)</code></h3>
                <p>Returns <code>true</code> if the attribute is set to a non-null or non-undefined value.</p>
            </article>

            <article id="model/clear">
                <h3><a href="<%- hr.urls.route("model/clear") %>">clear</a> <code>model.clear([options])</code></h3>
                <p>Clear the object attributes, <code>options</code> can contain <code>silent</code> to not triggering events <b>change</b> and <b>clear</b>.</p>
            </article>

            <article id="model/tojson">
                <h3><a href="<%- hr.urls.route("model/tojson") %>">toJSON</a> <code>model.toJSON()</code></h3>
                <p>Return a copy of the model's <a href="<%- hr.urls.route("model/attributes") %>">attributes</a> for JSON stringification. This can be used for persistence, serialization, or for augmentation before being sent to the server. The name of this method is a bit confusing, as it doesn't actually return a JSON string — but I'm afraid that it's the way that <a href="https://developer.mozilla.org/en-US/docs/JSON#toJSON()_method">the JavaScript API for JSON.stringify works</a>.</p>
                <%= view.component("code", {code: "model/tojson.js", run: true}) %>
            </article>
        </section>

        <section id="collection">
            <h2><a href="<%- hr.urls.route("collection") %>">Collection</a></h2>
            <p>Collections are ordered sets of <a href="<%- hr.urls.route("model") %>">models</a>. You can bind <code>"change"</code> events to be notified when any model in the collection has been modified, listen for <code>"add"</code> and <code>"remove"</code> events, and use a full suite of <a href="http://underscorejs.org/">Underscore.js</a> methods.</p>

            <p>Any event that is triggered on a model in a collection will also be triggered on the collection directly, for convenience. This allows you to listen for changes to specific attributes in any model in a collection, for example: <code>documents.on("change:selected", ...)</code></p>

            <article id="collection/extend">
                <h3><a href="<%- hr.urls.route("collection/extend") %>">extend</a> <code>hr.Collection.extend(properties, [classProperties])</code></h3>
                <p>To create a <b>Collection</b> class of your own, extend <b>hr.Collection</b>, providing instance <code>properties</code>, as well as optional <code>classProperties</code> to be attached directly to the collection's constructor function.</p>
            </article>

            <article id="collection/model">
                <h3><a href="<%- hr.urls.route("collection/model") %>">model</a> <code>collection.model</code></h3>
                <p>Override this property to specify the model class that the collection contains. If defined, you can pass raw attributes objects (and arrays) to <a href="<%- hr.urls.route("collection/add") %>">add</a> and <a href="<%- hr.urls.route("collection/reset") %>">reset</a>, and the attributes will be converted into a model of the proper type.</p>
                <%= view.component("code", {code: "collection/model.js"}) %>
                <p>A collection can also contain polymorphic models by overriding this property with a function that returns a model.</p>
                <%= view.component("code", {code: "collection/model_polymorphic.js"}) %>
            </article>

            <article id="collection/tojson">
                <h3><a href="<%- hr.urls.route("collection/tojson") %>">toJSON</a> <code>collection.toJSON()</code></h3>
                <p>Return an array containing the attributes hash of each model in the collection. This can be used to serialize and persist the collection as a whole. The name of this method is a bit confusing, because it conforms to <a href="https://developer.mozilla.org/en-US/docs/JSON#toJSON()_method">the JavaScript API for JSON.stringify works</a>.</p>
                <%= view.component("code", {code: "collection/tojson.js", run: true}) %>
            </article>
        </section>

        <section id="requests">
            <h2><a href="<%- hr.urls.route("requests") %>">Requests</a></h2>
            <p>The class <b>Requests</b> let you create simple or complex http requests in a easy way.</p>

            <article id="requests/class">
                <h3><a href="<%- hr.urls.route("requests/class") %>">Requests</a> <code>new hr.Requests(options)</code></h3>
                <p>The class <b>Requests</b> is very simple to use.</p>
                <%= view.component("code", {code: "requests/class.js", run: true}) %>
            </article>

            <p>The <b>Requests</b> class get some usefull shortcuts class methods such as <a href="<%- hr.urls.route("requests/get") %>">get</a> or <a href="<%- hr.urls.route("requests/post") %>">post</a></p>

            <article id="requests/get">
                <h3><a href="<%- hr.urls.route("requests/get") %>">get</a> <code>hr.Requests.get(url, arguments, options)</code></h3>
                <p>Easy way to do a <b>get</b> requests with some query arguments, it returns a <a href="<%- hr.urls.route("deferrer") %>"><code>Deferrer</code></a> object.</p>
                <%= view.component("code", {code: "requests/get.js", run: true}) %>
            </article>

            <article id="requests/post">
                <h3><a href="<%- hr.urls.route("requests/post") %>">post</a> <code>hr.Requests.post(url, arguments, options)</code></h3>
                <p>Easy way to do a <b>post</b> requests with some body arguments, it returns a <a href="<%- hr.urls.route("deferrer") %>"><code>Deferrer</code></a> object.</p>
                <%= view.component("code", {code: "requests/post.js", run: true}) %>
            </article>

            <article id="requests/getJSON">
                <h3><a href="<%- hr.urls.route("requests/getJSON") %>">getJSON</a> <code>hr.Requests.getJSON(url, arguments, options)</code></h3>
                <p>Like <b>get</b> but use JSONP callback to do cross-domain requests.</p>
                <%= view.component("code", {code: "requests/getjson.js", run: true}) %>
            </article>
        </section>

        <section id="logger">
            <h2><a href="<%- hr.urls.route("logger") %>">Logger</a></h2>
            <p>The class <b>Logger</b> let you manage different log in a standart way with a global configuration.</p>

            <article id="logger/addNamespace">
                <h3><a href="<%- hr.urls.route("logger/addNamespace") %>">Logger.addNamespace</a> <code>hr.Logger.addNamespace(namespace, [handler])</code></h3>
                <p><b>Logger</b> let you create logging object linked to a namespace and a handler.</p>
                <p>The <b>namespace</b> is a <em>string</em> defining the context of messages to this logger.</p>
                <p>The <b>handler</b> is an object with the following method : <code>"log", "debug", "warn", "error"</code></p>
                <%= view.component("code", {code: "logger/namespace.js", run: true}) %>
            </article>

            <article id="logger/logging">
                <h3><a href="<%- hr.urls.route("logger/logging") %>">Logger.logging</a> <code>hr.Logger.logging</code></h3>
                <p><b>logging</b> is a logger instance linked to the namespace <code>"base"</code>.</p>
                <p>Log messages are visible in the <b>console</b> of your navigator</p>
                <%= view.component("code", {code: "logger/logging.js", run: true}) %>
            </article>
        </section>

        <section id="router">
            <h2><a href="<%- hr.urls.route("router") %>">Router</a></h2>
            <p>Web applications often provide linkable, bookmarkable, shareable URLs for important locations in the app. Until recently, hash fragments (#page) were used to provide these permalinks, but with the arrival of the History API, it's now possible to use standard URLs (/page). hr.Router provides methods for routing client-side pages, and connecting them to actions and events.</p>

            <article id="router/extend">
                <h3><a href="<%- hr.urls.route("router/extend") %>">extend</a> <code>hr.Router.extend(properties, [classProperties])</code></h3>
                <p>Get started by creating a custom <b>router</b> class. Define actions that are triggered when certain URL fragments are matched, and provide a routes hash that pairs routes to actions.</p>
                <%= view.component("code", {code: "router/extend.js"}) %>
            </article>

            <article id="router/route">
                <h3><a href="<%- hr.urls.route("router/route") %>">route</a> <code>router.route(route, name, [callback])</code></h3>
                <p>Manually create a route for the router, The <code>route</code> argument may be a routing string or regular expression. Each matching capture from the route or regular expression will be passed as an argument to the callback. The <code>name</code> argument will be triggered as a <code>"route:name"</code> event whenever the route is matched.</p>
            </article>

            <article id="router/navigate">
                <h3><a href="<%- hr.urls.route("router/navigate") %>">navigate</a> <code>router.navigate(url, [mode, data, options])</code></h3>
                <p>Whenever you reach a point in your application that you'd like to save as a URL, call <b>navigate</b> in order to update the URL. If you wish to not call the route function, set the <b>trigger</b> option to <code>false</code>.</p>
            </article>

            <article id="router/start">
                <h3><a href="<%- hr.urls.route("router/start") %>">start</a> <code>router.start()</code></h3>
                <p>Start the router to listen to url changeemnt.</p>
                <%= view.component("code", {code: "router/route.js", run:true}) %>
            </article>
        </section>

        <section id="urls">
            <h2><a href="<%- hr.urls.route("urls") %>">Urls</a></h2>
            <p>The module <b>Urls</b> gives access to methods to simply calculate application urls.</p>

            <article id="urls/base">
                <h3><a href="<%- hr.urls.route("urls/base") %>">base</a> <code>hr.urls.route(*args)</code></h3>
                <p>Return complete url in the application using the configuration variable <code>baseUrl</code>.</p>
                <%= view.component("code", {code: "urls/base.js", run: true}) %>
            </article>

            <article id="urls/static">
                <h3><a href="<%- hr.urls.route("urls/static") %>">static</a> <code>hr.Urls.static(*args)</code></h3>
                <p>Return complete url in the application for a content in the static directory using the configuration variable <code>staticDirectory</code>.</p>
                <%= view.component("code", {code: "urls/static.js", run: true}) %>
            </article>

            <article id="urls/route">
                <h3><a href="<%- hr.urls.route("urls/route") %>">route</a> <code>hr.Urls.route(route, args, [base])</code></h3>
                <p>Return complete url in the application for a route and the route arguments using the configuration variable <code>router.mode</code>.</p>
                <%= view.component("code", {code: "urls/route.js", run: true}) %>
            </article>

            <article id="urls/rules">
                <h3><a href="<%- hr.urls.route("urls/rules") %>">extendRules</a> <code>hr.Urls.extendRules(rules)</code></h3>
                <p>Extend urls rules of module <b>Urls</b>.</p>
                <%= view.component("code", {code: "urls/rules.js", run:true}) %>
            </article>

            <article id="urls/template">
                <h3><a href="<%- hr.urls.route("urls/template") %>">In templates</a></h3>
                <p>Module <b>Urls</b> is accessible in templates using <code>hr.urls</code>.</p>
                <%= view.component("code", {code: "urls/template.html"}) %>
            </article>
        </section>

        <section id="i18n">
            <h2><a href="<%- hr.urls.route("i18n") %>">Internationalization (i18n)</a></h2>
            <p>The module <b>I18n</b> gives an easy way to manage different languages for your application.</p>

            <article id="i18n/loadLocale">
                <h3><a href="<%- hr.urls.route("i18n/loadLocale") %>">loadLocale</a> <code>hr.I18n.loadLocale(lang)</code></h3>
                <p>Load <b>translation</b> corresponding for the language <b>lang</b>.</p>
                <%= view.component("code", {code: "i18n/load.js", run: true}) %>
            </article>

            <article id="i18n/translate">
                <h3><a href="<%- hr.urls.route("i18n/translate") %>">translate</a> <code>hr.I18n.t(scope, [options])</code></h3>
                <p>Return the translation for <b>scope</b>. The translation string is parsed like a template using <b>options</b>.</p>
                <p>The translations tables is something like that :</p>
                <%= view.component("code", {code: "i18n/en.json"}) %>
            </article>

            <article id="i18n/template">
                <h3><a href="<%- hr.urls.route("i18n/template") %>">In templates</a></h3>
                <p>Module <b>i18n</b> is accessible directly in the template using <code>hr.I18n</code>.</p>
                <%= view.component("code", {code: "i18n/template.html"}) %>
            </article>
        </section>

        <section id="storage">
            <h2><a href="<%- hr.urls.route("storage") %>">Storage</a></h2>
            <p>The module <b>Storage</b> is a simple interface to the navigator <code>localStorage</code>.</p>
            <p>It supports storage of complex object and not just string.</p>
            <p>For gestion of cached values or resources, use instead module <a href="<%- hr.urls.route("cache") %>"><b>Cache</b></a>.</p>

            <article id="storage/get">
                <h3><a href="<%- hr.urls.route("storage/get") %>">get</a> <code>hr.Storage.get(key)</code></h3>
                <p>Return a value stored in the <code>localStorage</code>.</p>
            </article>

            <article id="storage/set">
                <h3><a href="<%- hr.urls.route("storage/set") %>">set</a> <code>hr.Storage.set(key, value)</code></h3>
                <p>Define a value to store in the <code>localStorage</code>.</p>
            </article>

            <article id="storage/remove">
                <h3><a href="<%- hr.urls.route("storage/remove") %>">remove</a> <code>hr.Storage.remove(key)</code></h3>
                <p>Remove a value from <code>localStorage</code>.</p>
            </article>

            <article id="storage/clear">
                <h3><a href="<%- hr.urls.route("storage/clear") %>">clear</a> <code>hr.Storage.clear()</code></h3>
                <p>Clear all the values stored in the <code>localStorage</code>.</p>
            </article>

            <article id="storage/usedSpace">
                <h3><a href="<%- hr.urls.route("storage/usedSpace") %>">usedSpace</a> <code>hr.Storage.usedSpace()</code></h3>
                <p>Return the number of value stored in <code>localStorage</code>.</p>
            </article>
        </section>

        <section id="cache">
            <h2><a href="<%- hr.urls.route("cache") %>">Cache</a></h2>
            <p>The module <b>Cache</b> use the module <a href="<%- hr.urls.route("storage") %>"><b>Storage</b></a> to storage content for a timelapse.</p>
            <p>The good way to use <b>caching</b> is to use <a href="<%- hr.urls.route("cache/namespace") %>"><b>Cache.namespace</b></a>.</p>

            <p><b>Cache</b> can store any json-serializable <b>value</b> to any json-serializable <b>key</b>. Cache stored <b>key</b> is relative to the application build revision.</p>

            <%= view.component("code", {code: "cache/key.js"}) %>

            <article id="cache/get">
                <h3><a href="<%- hr.urls.route("cache/get") %>">get</a> <code>hr.Cache.get(namespace, key)</code></h3>
                <p>Return a value stored in the <code>Storage</code>.</p>
            </article>

            <article id="cache/set">
                <h3><a href="<%- hr.urls.route("cache/set") %>">set</a> <code>hr.Cache.set(namespace, key, value, expiration)</code></h3>
                <p>Define a value to store in the <code>Storage</code> for a timelapse.</p>
                <p><b>expiration</b> define the timelapse in seconds, if <b>expiration</b> <&lsaquo; 0 then value don't have a timelife.</p>
            </article>

            <article id="cache/remove">
                <h3><a href="<%- hr.urls.route("cache/remove") %>">remove</a> <code>hr.Cache.remove(namespace, key)</code></h3>
                <p>Remove a value from <code>Storage</code>.</p>
            </article>

            <article id="cache/clear">
                <h3><a href="<%- hr.urls.route("cache/clear") %>">clear</a> <code>hr.Cache.clear()</code></h3>
                <p>Clear the all cache without clearing the all <code>Storage</code>.</p>
            </article>

            <article id="cache/namespace">
                <h3><a href="<%- hr.urls.route("cache/namespace") %>">namespace</a> <code>hr.Cache.namespace(namespace)</code></h3>
                <p>Return a cache interface centered arround a namespace.</p>
                <%= view.component("code", {code: "cache/namespace.js", run: true}) %>
            </article>
        </section>

        <section id="resources">
            <h2><a href="<%- hr.urls.route("resources") %>">Resources</a></h2>
            <p>The module <b>Resources</b> let you load resources (such as templates, ...) in a standart way.</p>

            <article id="resources/load">
                <h3><a href="<%- hr.urls.route("resources/load") %>">load</a> <code>hr.Resources.load(namespace, ressource)</code></h3>
                <p>Load a ressource in a namespace and return a <a href="<%- hr.urls.route("deferred") %>"><code>Deferred</code></a>.</p>
                <%= view.component("code", {code: "resources/load.js", run: true}) %>
            </article>

            <article id="resources/addNamespace">
                <h3><a href="<%- hr.urls.route("resources/addNamespace") %>">addNamespace</a> <code>hr.Resources.addNamespace(namespace, options)</code></h3>
                <p>Add a namespaces for resources with options for loading.</p>
                <%= view.component("code", {code: "resources/namespace.js", run: true}) %>
            </article>

            <article id="resources/addLoader">
                <h3><a href="<%- hr.urls.route("resources/addLoader") %>">addLoader</a> <code>hr.Resources.addLoader(name, handler)</code></h3>
                <p>Add a new loader for loading resources.</p>
                <p>Base loader are :
                    <ul>
                        <li><b>http</b> : Load resources using http requests and caching</li>
                        <li><b>require</b> : Load resources from application source code using require</li>
                    </ul>
                </p>
                <%= view.component("code", {code: "resources/loader.js", run: true}) %>
            </article>
        </section>
    </div>
</div>