{"name":"bugs","version":"0.1.0","description":"A unified interface to common debuggers (gdb, jdb, pdb, ...) ","main":"index.js","scripts":{"test":"echo \"Error: no test specified\" && exit 1"},"repository":{"type":"git","url":"https://github.com/FriendCode/bugs.git"},"keywords":["gdb","pdb","jdb","bugs","debugger"],"author":{"name":"Aaron O'Mullan","email":"aaron.omullan@friendco.de"},"dependencies":{"q":"1.0.0","lodash":"2.4.1","event-stream":"3.1.0","pty.js":"0.2.3"},"bugs":{"url":"https://github.com/FriendCode/bugs/issues"},"_id":"bugs@0.1.0","dist":{"shasum":"f638419670a6694e6dd60c3a471b0876b4608528","size":297619,"noattachment":false,"tarball":"http://registry.npm.taobao.org/bugs/download/bugs-0.1.0.tgz"},"_from":".","_npmVersion":"1.3.8","_npmUser":{"name":"aarono","email":"aaron.omullan@gmail.com"},"maintainers":[{"name":"aarono","email":"aaron.omullan@gmail.com"}],"directories":{},"publish_time":1394946832079,"_cnpm_publish_time":1394946832079,"readme":"bugs.js\n====\n\nA *NodeJS* library providing a unified interface to common debuggers (`gdb`, `jdb`, `pdb`, ...). It's meant for building developer tools (debug tools, IDEs, etc ...), built for [Codebox](https://github.com/FriendCode/codebox)\n\n## Supported debuggers\n  - `gdb` : `c/c++` (and any native binaries really)\n  - `jdb` : `java` (and anything running on the JVM)\n  - `pdb` : `python`\n  - `rdb` : `ruby`\n  - Feel free to send Pull Requests for more\n\nRight now we interface with the current debugger through their command line programs and smartly writing and reading from their `stdout`/`stdin`.\n\n## Install\n:warning: *Warning*: `bugs` is not yet published to npm\n```\nnpm install bugs\n```\n\n## Examples\n\n#### `python` with `pdb`\n\n```js\nvar bugs = require('bugs');\n\n// Use pdb to debug a python file\nvar dbg = bugs.pdb('./some_file.py');\n\n// Debug \"main\" function\ndbg.init()\n.then(function() {\n    return dbg.break('main');\n})\n.then(function() {\n    // Run debugger\n    return dbg.run();\n})\n.then(function() {\n    // Get backtrace\n    return dbg.backtrace();\n})\n.then(function(trace) {\n    // Display trace & quit\n    console.log('trace =', trace)\n    return dbg.quit();\n})\n.done();\n```\n\n#### Native binaries with `gdb`\n\n```js\nvar bugs = require('bugs');\n\n// Use gdb to unix \"ls\" binary\nvar dbg = bugs.gdb('ls');\n\n// Debug \"main\" function\ndbg.init()\n.then(function() {\n    return dbg.break('main');\n})\n.then(function() {\n    // Run \"ls\" on a given folder\n    return dbg.run('-al /tmp');\n})\n.then(function() {\n    // Get backtrace\n    return dbg.backtrace();\n})\n.then(function(trace) {\n    // Display trace & quit\n    console.log('trace =', trace)\n    return dbg.quit();\n})\n.done();\n```\n\n# Commands\n\n## General\n\n### `.run(arg1, arg2, ...)`\nRun file to debug with given args\n\n### `.restart()`\nRestart program\n\n### `.quit()`\nQuit current instance of the debugger (this isn't terribly useful)\n\n\n## Movement\n\n### `.finish()`\nRun until current method returns.\n\n### `.step()`\nExecute and step into function\n\n### `.stepi()`\nExecute current instruction\n\n### `.continue()`\nKeep running from here\n\n### `.next()`\nRun to the next line of the current function\n\n### `.up()`\nMove one level up in the stack trace\n\n### `.down()`\nMove one level down in the stack trace\n\n\n## Examination\n\n### `.eval(code)`\nEvaluate a string of `code` and print the result\n\n### `.backtrace()`\nPrint backtrace of current stack\n\n### `.list()`\nList source code of current location\n\n### `.locals()`\nGet local variables of current stack\n\n### `.globals()`\nGet global variables\n\n\n## Breakpoints\n\n### `.breakpoints()`\nLists currently set breakpoints\n\n### `.breakpoint(location)`\nSet a new breakpoint at `location` (`location` can be a line number, function address ...)\n\n### `.clear(location)`\nClear breakproint for `location` (see above for `location`)\n\n## Aliases\n\n### `.start()`\nAlias to `run`\n\n### `.stop()`\nAlias to `quit`\n\n# Events\n\n### `started`\nSignals when the debugger is ready to receive commands.\n`.init()` resolves when `started` is emitted (you should probably use that).\n\n### `update`\nProvides updates when state of process changes. And updates not request or results of commands executed.\n\n","_etag":"\"10db-3vFlWWSG8FONEsA1Q5OrOQ\""}